<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <title>stlite app</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.34.0/build/stlite.css"
    />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-31BSNBR4N9"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-31BSNBR4N9');
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.34.0/build/stlite.js"></script>
    <script>
stlite.mount(
  {
    requirements: ["pandas","seaborn"], // Packages to install
    entrypoint: "Home.py", // The target file of the `streamlit run` command
    files: {
      "figure.png":{
        url: "https://raw.githubusercontent.com/COBA-NIH/bioimage_object_analysis_schema/main/figure.png",
      },
      "jsons/master_schema.json":{
        url: "https://raw.githubusercontent.com/COBA-NIH/bioimage_object_analysis_schema/main/jsons/master_schema.json",
      },
      "bioimage_object_analysis_questions.json":{
        url: "https://raw.githubusercontent.com/COBA-NIH/bioimage_object_analysis_schema/main/bioimage_object_analysis_questions.json",
      },
      "bioimage_object_analysis_questions.csv":{
        url: "https://raw.githubusercontent.com/COBA-NIH/bioimage_object_analysis_schema/main/bioimage_object_analysis_questions.csv",
      },
      "Home.py": `
import json
import streamlit as st

from utils import load_schema

load_schema(from_master=True,rewrite_master=False)

"""
# Welcome to the home page for the "Twenty Questions of Bioimage Object Analysis" project!

This website is associated with the paper "The Twenty Questions of Bioimage Object Analysis" by Beth A. Cimini and Kevin W. Eliceiri, currently under revision at Nature Methods.

This schema is currently under development; stay tuned for more updates.
Previous versions of this schema are currently best found on [Zenodo](https://doi.org/10.5281/zenodo.7654937)

Last updated - July 7, 2023

App made by Beth Cimini, Broad Institute, 2023, as part of the Center for Open Bioimage Analysis

[Check out this app's source on GitHub](https://github.com/COBA-NIH/bioimage_object_analysis_schema)

[![DOI](https://zenodo.org/badge/629135528.svg)](https://zenodo.org/badge/latestdoi/629135528) (Source code DOI)

[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.7654937.svg)](https://doi.org/10.5281/zenodo.7654937) (Original schema DOI)
"""

st.write(json.load(open('bioimage_object_analysis_questions.json')))

st.download_button('Download these questions and answers as a json file',open('bioimage_object_analysis_questions.json'),'bioimage_object_analysis_questions.json')
st.download_button('Download these questions and answers as a csv file',open('bioimage_object_analysis_questions.csv'),'bioimage_object_analysis_questions.csv')
`,
      "utils.py": `
import json
import os

import pandas
import streamlit as st

def load_schema(from_master = True, rewrite_master = False, master_file = 'jsons/master_schema.json', short_master_file = 'bioimage_object_analysis_questions.json'):
    if from_master:
        master_schema_dict = json.load(open(master_file))
    else:
        json_q_dict = {json.load(open(f"jsons/{x}"))['index']:json.load(open(f"jsons/{x}")) for x in os.listdir('jsons') if '.json' in x if 'master_schema' not in x}
        count_list = list(json_q_dict.keys()) 
        count_list = [x for x in count_list if x >= 0] #allow for dummy files with an index of -1
        count_list.sort()

        master_schema_dict = {}
        for eachcount in count_list:
            master_schema_dict[eachcount]=json_q_dict[eachcount]
        
        if rewrite_master == True:
            with open(master_file,'w') as mf:
                json.dump(master_schema_dict,mf)
            master_schema_short = {}
            for eachcount in count_list:
                question = json_q_dict[eachcount]
                master_schema_short[question['full_name']]=list(question['options'].keys())
                with open(short_master_file,'w') as mfs:
                    json.dump(master_schema_short,mfs)
            max_val = max([len(val) for val in master_schema_short.values()])
            short_schema_padded = {k:v+['']*(max_val - len(v)) for k,v in master_schema_short.items()}
            df = pandas.DataFrame(short_schema_padded)
            df.to_csv('bioimage_object_analysis_questions.csv',index=False)

    return master_schema_dict

def display_interactive_schema():
    st.write("# Tell us about your data")
    st.write("")
    st.write("#### When analyzing multiple kinds of objects, these set of questions should be independently answered for each object to be segmented.")
    st.write("")
    st.write("Please note that questions and answers may be edited or removed in future versions of the schema. Last updated July 7th 2023")

    json_q_dict = load_schema(from_master=True,rewrite_master=False)
    count_list = count_list = list(json_q_dict.keys())

    setting_dict = {}

    section_start_text = {
        "0":"### Questions about your images that may affect preprocessing before segmentation happens",
        "9":"### Questions about your objects that may affect specific settings during segmentation",
        "18":"### Questions about which measurements must be made of your objects"
        }

    for eachcount in count_list:
        if eachcount in list(section_start_text.keys()):
            st.write(section_start_text[eachcount])
        question = json_q_dict[eachcount]
        if question["short_name"]=='3D': #some answers will be different in 2D vs 3D
            is_3D_question = eachcount
        if question['select_all']:
            setting_dict[eachcount] = st.multiselect(question['full_name'],list(question['options'].keys()),
                                                    help=question['long_description'])
        elif question['slider']:
            setting_dict[eachcount] = st.select_slider(question['full_name'],list(question['options'].keys()),
                                                    value=list(question['options'].keys())[question["default_option_index"]],
                                                    help=question['long_description'])
        else:
            setting_dict[eachcount] = st.selectbox(question['full_name'],list(question['options'].keys()),
                                                index=question["default_option_index"],
                                                help=question['long_description'])

    is_3D = setting_dict[is_3D_question] == "Yes"

    by_name_dict = {json_q_dict[x]['full_name']:setting_dict[x] for x in count_list}
    st.download_button('Download my answers as a json file',json.dumps(by_name_dict),'dataset_description.json')
    return json_q_dict,setting_dict,is_3D

def make_fig():
    # much of this stolen from https://github.com/mwaskom/seaborn/blob/bf0cfec0627bee4b757f033ff504c0a520a3cd5b/doc/sphinxext/tutorial_builder.py#L130
    # subplot wrapping from https://gist.github.com/dneuman/90af7551c258733954e3b1d1c17698fe
    import json
    import matplotlib as mpl
    import matplotlib.text as mtext
    from matplotlib.patches import FancyBboxPatch
    import matplotlib.pyplot as plt
    import seaborn as sns

    qs=json.load(open('jsons/master_schema.json'))
    categories = ['Measurement','Object','Image']

    dict_for_plotting = {'Question':[x['full_name'] for x in qs.values()],
                        'Category':[x['section'].title() for x in qs.values()],
                        'Answers':[list(x['options'].keys()) for x in qs.values()],
                        }
    class WrapText(mtext.Text):
        """
        WrapText(x, y, s, width, widthcoords, **kwargs)
        x, y       : position (default transData)
        text       : string
        width      : box width
        widthcoords: coordinate system (default screen pixels)
        **kwargs   : sent to matplotlib.text.Text
        Return     : matplotlib.text.Text artist
        """
        def __init__(self,
                    x=0, y=0, text='',
                    width=0,
                    widthcoords=None,
                    **kwargs):
            mtext.Text.__init__(self,
                    x=x, y=y, text=text,
                    wrap=True,
                    clip_on=False,
                    **kwargs)
            if not widthcoords:
                self.width = width
            else:
                self.width = widthcoords.transform_point((width,0))[0]

        def _get_wrap_line_width(self):
            return self.width

    mpl.rcParams['figure.subplot.wspace']=mpl.rcParams['figure.subplot.hspace']=0.001
    fig = plt.figure(figsize=[10,12],dpi=300)
    with sns.axes_style("white"):
        axes = fig.subplots(ncols=4,nrows=5,sharex=True,sharey=True)
    deep = sns.color_palette("colorblind")
    colors ={"Image":deep[0], "Object":deep[1], "Measurement":deep[2]}
    dark = sns.color_palette("dark")
    text_colors = {"Image":dark[0], "Object":dark[1], "Measurement":dark[2]}
    pad = 0.04
    for eachq in range(20):
        x = eachq %4
        y = int(eachq /4)
        color = colors[dict_for_plotting['Category'][eachq]]+(.25,)
        text_color = text_colors[dict_for_plotting['Category'][eachq]]
        ax = axes[y][x]
        ax.set_axis_off()
        ax.set(xlim=(0, 1), ylim=(0, 1))
        ax.add_artist(FancyBboxPatch(
            (0.05, 0.78), 0.89, 0.15, f"round,pad={pad}",
            linewidth=1, edgecolor=text_color, facecolor=color,
        ))
        wtxt = WrapText(
            0.5, 0.85, f"{eachq+1}) {dict_for_plotting['Question'][eachq]}",width=550, widthcoords=None,
            ha="center", va='center',ma="center", size=7, color=text_color
        )
        ax.add_artist(wtxt)
        answers = dict_for_plotting['Answers'][eachq]
        pad2 = 0.01
        h = (0.72-(3*pad2*len(answers)))/(len(answers))
        color2 = colors[dict_for_plotting['Category'][eachq]]+(.15,)
        for eachanswer in range(len(answers)):
            y = 0.75-((h+(3*pad2))*(eachanswer+1))
            ax.add_artist(FancyBboxPatch(
            (0.1, y), 0.8, h, f"round,pad={pad2}",
            linewidth=1, edgecolor=text_color, facecolor=color2,))
            wtxt = WrapText(
            0.5, y+(0.5*h), f"{answers[eachanswer]}",width=430, widthcoords=None,
            ha="center", va='center',ma="center", size=7, color=text_color,linespacing=1)
            ax.add_artist(wtxt)
    plt.savefig('figure.png',dpi=300,bbox_inches='tight')

#on import of this, which will be on app reboot/rebuild, remake everything to ensure stuff is up to date
load_schema(from_master=True,rewrite_master=False)
make_fig()
`,
      "pages/1_Schema_Definitions.py": `
import json
import os
import sys

import streamlit as st

sys.path.append('..')
from bioimage_object_analysis_schema.utils import load_schema

json_q_dict = load_schema(from_master=True,rewrite_master=False)

"""
# Explanation of each of the question in the schema

Please note that questions and answers may be edited or removed in future versions of the schema. Last updated July 7th 2023
"""

for _,values in json_q_dict.items():
    st.write(f"## {values['full_name']}")
    st.write(f"  _{values['long_description']}_")
    st.write(f"  **Workflow step category**: {values['section']}")
    st.write(f"  **Current possible answers in the schema**: {' | '.join(list(values['options'].keys()))}")

`,
      "pages/2_Figure.py": `
import streamlit as st

st.image('figure.png')
`,
      "pages/3_Interactive_Schema.py": `
import json
import os
import sys

import streamlit as st

sys.path.append('..')
from bioimage_object_analysis_schema.utils import display_interactive_schema


json_q_dict,setting_dict,is_3D = display_interactive_schema()
`,
      "pages/4_CellProfiler_Pipeline_Suggester.py": `
import json
import os
import sys

import streamlit as st

sys.path.append('..')
from bioimage_object_analysis_schema.utils import display_interactive_schema


json_q_dict,setting_dict,is_3D = display_interactive_schema()

def follow_answer_tree(json_q_dict,eachkey,setting_dict,is_3D):
    if json_q_dict[eachkey]["changes_based_on_3d"]:
        if type(setting_dict[eachkey]) == list:
            for eachsubkey in setting_dict[eachkey]:
                answer = json_q_dict[eachkey]['options'][eachsubkey]["cellprofiler_suggester"][f"3D_{is_3D}"]
                if answer:#just don't show anything if we haven't written the rec yet
                    st.write(answer)
        else:
            answer = json_q_dict[eachkey]['options'][setting_dict[eachkey]]["cellprofiler_suggester"][f"3D_{is_3D}"]
            if answer: #just don't show anything if we haven't written the rec yet
                st.write(answer)              

    else:
        if type(setting_dict[eachkey]) == list:
            for eachsubkey in setting_dict[eachkey]:
                answer = json_q_dict[eachkey]['options'][eachsubkey]["cellprofiler_suggester"]
                if answer:#just don't show anything if we haven't written the rec yet
                    st.write(answer)
        else:
            answer = json_q_dict[eachkey]['options'][setting_dict[eachkey]]["cellprofiler_suggester"]
            if answer: #just don't show anything if we haven't written the rec yet
                st.write(answer)   

"""
# CellProfiler pipeline recommendations

See below for pipeline suggestions based on the answers to your questions. Note that some "best-case-scenario answers" where therefore no special handling is needed will not generate suggestions, so the number of suggestions may not match the number of questions.

Last updated July 7 2023
"""

"""
## CellProfiler pipeline recommendations - image preprocessing
"""
for eachkey in setting_dict.keys():
    if json_q_dict[eachkey]["section"] == 'image':
        follow_answer_tree(json_q_dict,eachkey,setting_dict,is_3D)

"""
## CellProfiler pipeline recommendations - object specifications
"""

for eachkey in setting_dict.keys():
    if json_q_dict[eachkey]["section"] == 'object':
        follow_answer_tree(json_q_dict,eachkey,setting_dict,is_3D)


"""
## CellProfiler pipeline recommendations - measurement specifications
"""

for eachkey in setting_dict.keys():
    if json_q_dict[eachkey]["section"] == 'measurement':
        follow_answer_tree(json_q_dict,eachkey,setting_dict,is_3D)
    

`,
    },
  },
  document.getElementById("root")
);
    </script>
  </body>
</html>
